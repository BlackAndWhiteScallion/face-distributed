o cut a video into frames, detect faces, form Delaunay triangles, and put the frames back into a video, you can use the following algorithm:

Import the necessary libraries: cv2 for video processing and face detection, dlib for face landmarks, numpy for array manipulation, and scipy for Delaunay triangulation.

Load the video using cv2.VideoCapture and retrieve the total number of frames.

Create an output video file using cv2.VideoWriter.

Initialize the face detector and landmarks predictor using dlib.

Iterate over each frame of the video:

Extract the frame using cv2.VideoCapture.read.

Detect faces in the frame using the face detector from dlib.

For each detected face, predict facial landmarks using the landmarks predictor from dlib.

Convert the facial landmarks to a numpy array.

Compute the Delaunay triangulation using scipy.spatial.Delaunay.

Draw the Delaunay triangulation on the frame using cv2.polylines.

Write the frame with the triangulation to the output video using cv2.VideoWriter.write.

Release the video capture and writer objects.

Here's an example implementation of the algorithm:


// CODE
import cv2
import dlib
import numpy as np
from scipy.spatial import Delaunay

# Load the face detector and landmarks predictor from dlib
detector = dlib.get_frontal_face_detector()
predictor = dlib.shape_predictor('shape_predictor_68_face_landmarks.dat')  # Download from dlib's website

# Path to the input video file
input_video_path = 'input_video.mp4'

# Path to the output video file
output_video_path = 'output_video.mp4'

# Open the input video
video = cv2.VideoCapture(input_video_path)

# Retrieve the total number of frames
total_frames = int(video.get(cv2.CAP_PROP_FRAME_COUNT))

# Get the frame width, height, and frames per second (fps)
frame_width = int(video.get(cv2.CAP_PROP_FRAME_WIDTH))
frame_height = int(video.get(cv2.CAP_PROP_FRAME_HEIGHT))
fps = video.get(cv2.CAP_PROP_FPS)

# Create the output video writer
fourcc = cv2.VideoWriter_fourcc(*'mp4v')
output_video = cv2.VideoWriter(output_video_path, fourcc, fps, (frame_width, frame_height))

# Process each frame of the video
for frame_index in range(total_frames):
    # Read the frame
    ret, frame = video.read()
    if not ret:
        break
    
    # Convert the frame to grayscale for face detection
    gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)
    
    # Detect faces in the frame
    faces = detector(gray)
    
    # Iterate over each detected face
    for face in faces:
        # Predict facial landmarks for the face
        landmarks = predictor(gray, face)
        
        # Extract the x, y coordinates of the facial landmarks
        points = []
        for n in range(68):  # Assuming 68 landmarks are being used
            x = landmarks.part(n).x
            y = landmarks.part(n).y
            points.append((x, y))
        
        # Convert the points to a numpy array
        points = np.array(points)
        
        # Compute Delaunay triangulation
        tri = Delaunay(points)
        
        # Draw the Delaunay triangulation on the frame
        for triangle in tri.simplices:
            pt1 = tuple(points[triangle[0]])
            pt2 = tuple(points[triangle[1]])
            pt3 = tuple(points[triangle[2]])
            cv2.polylines(frame, [np.array([pt1, pt2, pt3], dtype=np.int32)], True, (0, 255, 0), 2)
    
    # Write the frame with the triangulation to the output video
    output_video.write(frame)
    
    # Display the processed frame (optional)
    cv2.imshow('Frame', frame)
    if cv2.waitKey(1) & 0xFF == ord('q'):
        break

# Release the video capture and writer objects
video.release()
output_video.release()

# Close all OpenCV windows
cv2.destroyAllWindows()

make sure to replace 'shape_predictor_68_face_landmarks.dat' with the correct path to the pre-trained face landmarks model (shape_predictor_68_face_landmarks.dat).

# tutorial for opencv use: 
https://techtutorialsx.com/2021/04/29/python-opencv-splitting-video-frames/
https://theailearner.com/2018/10/15/creating-video-from-images-using-opencv-python/